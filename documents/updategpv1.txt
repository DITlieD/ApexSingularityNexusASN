Update forge/gp_framework.py (Integration)

Integrate Dual-Fitness, the Validation Gauntlet, and SAE into the main Forge workflow.. Merge this code carefully with the existing gp_framework.py 


# In forge/gp_framework.py

import operator
import random
import numpy
import pandas as pd
import polars as pl # Import Polars
import time
import json
import os

from deap import algorithms, base, creator, tools, gp

# Import the engines and managers
from causal_engine import perform_causal_discovery
from chimera_engine import find_dsg
from fitness_ttt import evaluate_individual
from serialize_strategy import deap_to_json
from validation_gauntlet import ValidationGauntlet # NEW IMPORT
from sae_manager import DNAVectorizer, FitnessOracle, SurrogateAssistedEvolution # NEW IMPORT


# --- Global Definitions ---
# NOTE: Update this list to match the features available in the Rust backtester AND the Causal data
POTENTIAL_FEATURES = ['imbalance', 'pressure', 'clv']
TARGET_VARIABLE = 'target_return'

# ... (Helper Functions: protectedDiv, if_then_else, initDualTree, cxOnePointDual, mutUniformDual, combined_height) ...
# ... (Type Creation: FitnessMax, Individual) ...


# --- 3. Dynamic Toolbox Setup (The Core ACN Integration) ---

def setup_dynamic_toolbox(causal_features, dsg, historical_data_pl: pl.DataFrame):
    """
    Dynamically configures the GP toolbox based on causal analysis and the DSG.
    """
    toolbox = base.Toolbox()
    
    # 1. Create the filtered Primitive Set (Causality)
    pset = gp.PrimitiveSet("MAIN", len(causal_features))
    
    # ... [PSet configuration: Add Primitives, Ephemerals, Rename Arguments] ...
    # (Use the definitions from the previous implementation steps)

    # 2. Register GP operators
    # ... [expr, individual, population registration] ...

    # 3. Register Evaluation (Dual-Fitness)
    # We pass the historical data and feature names required by the Causal Fitness backtester
    toolbox.register("evaluate", evaluate_individual, 
                     dsg=dsg, 
                     historical_data_pl=historical_data_pl, 
                     feature_names=causal_features)

    # 4. Register Selection and Mutation
    # ... [select, mate, expr_mut, mutate registration and decorators] ...

    return toolbox, pset

# --- Main Execution (The Forge Cycle) ---
def main(historical_data_path=None, run_chimera=True, use_sae=True):
    print("--- ASN Forge Cycle Start (ACN Synthesis) ---")

    # 1. Data Preparation (Using Polars for Rust compatibility)
    print("1. Preparing Data...")
    # (Data generation/loading logic using Polars - Placeholder implementation shown)
    T = 5000
    # ... (Synthetic data creation logic) ...
    
    # CRITICAL: Ensure data types are Decimal for Rust Backtester compatibility
    decimal_cols = POTENTIAL_FEATURES + [TARGET_VARIABLE, 'close']
    data = data.with_columns([
        pl.col(col).cast(pl.Decimal(scale=8, precision=None)) for col in decimal_cols if col in data.columns
    ])


    # 2. Causal Discovery (Tigramite requires Pandas/Numpy and Floats)
    data_pd = data.to_pandas()
    # Convert Decimal columns to float for Tigramite compatibility
    for col in data_pd.columns:
        data_pd[col] = data_pd[col].astype(float)

    print("\n2. Running Causal Discovery...")
    # ... (Causal discovery logic remains the same, using data_pd) ...
    # Ensure we only use features available in the Rust simulator
    available_causal_features = [f for f in causal_features if f in POTENTIAL_FEATURES]
    if not available_causal_features:
        available_causal_features = POTENTIAL_FEATURES


    # 3. Chimera Engine (Find DSG)
    # ... (Chimera logic remains the same) ...

    # 4. Setup Dynamic Toolbox (Passing Polars DataFrame with Decimals)
    columns_for_rust = ['close'] + available_causal_features
    # Ensure the data passed to Rust only contains the necessary columns
    historical_data_pl = data.select(columns_for_rust)
    
    toolbox, pset = setup_dynamic_toolbox(available_causal_features, dsg, historical_data_pl)

    # 5. Evolution (Hybrid Crucible with SAE)
    
    # SAE Configuration
    POP_SIZE = 500 if use_sae else 100
    NGEN = 25
    TOP_K_PERCENT = 0.05 # Evaluate top 5%

    print(f"\n--- Starting GP Evolution (Synthesis) ---")
    print(f"SAE Enabled: {use_sae}. Pop Size: {POP_SIZE}. Generations: {NGEN}.")

    pop = toolbox.population(n=POP_SIZE)
    hof = tools.HallOfFame(1)

    # (Statistics setup remains the same)

    try:
        if use_sae:
             # Initialize SAE components
            vectorizer = DNAVectorizer(pset)
            oracle = FitnessOracle(vectorizer)
            sae_manager = SurrogateAssistedEvolution(oracle, top_k_percent=TOP_K_PERCENT)
            
            # Run the custom SAE evolutionary loop
            run_evolutionary_loop(pop, toolbox, NGEN, mstats, hof, sae_manager)
        else:
            # Run standard evolution
            algorithms.eaSimple(pop, toolbox, cxpb=0.8, mutpb=0.3, ngen=NGEN, stats=mstats, halloffame=hof, verbose=True)
    except Exception as e:
         print(f"\nERROR during evolution. Ensure Rust 'nexus' module is compiled and accessible. Details: {e}")
         return


    # 6. Validation Gauntlet (New Step)
    if hof:
        best_ind = hof[0]
        print(f"\nEvolution Complete. Best Fitness (Combined TTT Score): {best_ind.fitness.values[0]:.2f}")
        
        # Initialize and run the Gauntlet
        gauntlet = ValidationGauntlet(historical_data_pl, available_causal_features, pset)
        validation_passed = gauntlet.run(best_ind)

        if validation_passed:
            print("\n--- GAUNTLET PASSED: Deploying Strategy ---")
            # Save the best strategy (The Pit Crew in Rust will detect this file)
            # ... (Save logic)
        else:
            print("\n--- GAUNTLET FAILED: Strategy Discarded ---")


    print("\n--- ASN Forge Cycle Complete ---")
    return pop, mstats, hof

# NEW: Unified Evolutionary Loop (Handles both Standard and SAE)
def run_evolutionary_loop(population, toolbox, ngen, stats, halloffame, sae_manager=None):
    logbook = tools.Logbook()
    logbook.header = ['gen', 'nevals'] + (stats.fields if stats else [])

    # Evaluate the initial population entirely (Required for both standard and seeding SAE Oracle)
    print("Evaluating initial population...")
    fitnesses = toolbox.map(toolbox.evaluate, population)
    for ind, fit in zip(population, fitnesses):
        ind.fitness.values = fit
        if sae_manager:
            sae_manager.oracle.add_training_data(ind, fit[0])

    nevals = len(population)
    
    if sae_manager:
        sae_manager.oracle.train()

    if halloffame:
        halloffame.update(population)

    record = stats.compile(population) if stats else {}
    logbook.record(gen=0, nevals=nevals, **record)
    print(logbook.stream)

    # Begin the evolution
    for gen in range(1, ngen + 1):
        # 1. Generate Offspring (Crossover and Mutation)
        offspring = algorithms.varAnd(population, toolbox, cxpb=0.8, mutpb=0.3)

        if sae_manager:
            # 2. Screen and Evaluate using SAE Manager
            nevals = sae_manager.screen_and_evaluate(offspring, toolbox)
        else:
            # 2. Standard Evaluation
            invalid_ind = [ind for ind in offspring if not ind.fitness.valid]
            fitnesses = toolbox.map(toolbox.evaluate, invalid_ind)
            for ind, fit in zip(invalid_ind, fitnesses):
                ind.fitness.values = fit
            nevals = len(invalid_ind)

        # 3. Update Hall of Fame
        if halloffame:
            halloffame.update(offspring)

        # 4. Selection (Replace the population by the offspring)
        population[:] = toolbox.select(offspring, k=len(population))

        # 5. Record Statistics
        record = stats.compile(population) if stats else {}
        logbook.record(gen=gen, nevals=nevals, **record)
        print(logbook.stream)

    return population, logbook